package market

import (
	"encoding/json"
	"fmt"
	"log"
	"strings"
	"sync"
	"time"

	"github.com/nats-io/nats.go"
)

// EnhancedNATSPublisher - —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π NATS publisher
type EnhancedNATSPublisher struct {
	nc        *nats.Conn
	isRunning bool
	mu        sync.Mutex

	// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
	messagesSent map[string]int64
	statsMux     sync.RWMutex
}

// EnhancedQuoteData - —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è NATS
type EnhancedQuoteData struct {
	// –ë–∞–∑–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
	Symbol    string    `json:"symbol"`
	Price     float64   `json:"price"`
	Market    string    `json:"market"`
	Timestamp time.Time `json:"timestamp"`

	// –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
	Volume24h float64 `json:"volume_24h,omitempty"`
	Change24h float64 `json:"change_24h,omitempty"`
	High24h   float64 `json:"high_24h,omitempty"`
	Low24h    float64 `json:"low_24h,omitempty"`

	// Trade –¥–∞–Ω–Ω—ã–µ
	LastTradePrice float64 `json:"last_trade_price,omitempty"`
	LastTradeSize  float64 `json:"last_trade_size,omitempty"`
	LastTradeSide  string  `json:"last_trade_side,omitempty"`
	TradeCount     int64   `json:"trade_count,omitempty"`

	// Orderbook –¥–∞–Ω–Ω—ã–µ
	BestBid       float64 `json:"best_bid,omitempty"`
	BestAsk       float64 `json:"best_ask,omitempty"`
	Spread        float64 `json:"spread,omitempty"`
	SpreadPercent float64 `json:"spread_percent,omitempty"`
	BidPressure   float64 `json:"bid_pressure,omitempty"`
	AskPressure   float64 `json:"ask_pressure,omitempty"`

	// Kline –¥–∞–Ω–Ω—ã–µ
	KlineOpen   float64 `json:"kline_open,omitempty"`
	KlineHigh   float64 `json:"kline_high,omitempty"`
	KlineLow    float64 `json:"kline_low,omitempty"`
	KlineClose  float64 `json:"kline_close,omitempty"`
	KlineVolume float64 `json:"kline_volume,omitempty"`

	// –ê–Ω–∞–ª–∏—Ç–∏–∫–∞
	Analytics *AnalyticsMetrics `json:"analytics,omitempty"`
}

func NewEnhancedNATSPublisher(natsURL string) (*EnhancedNATSPublisher, error) {
	if natsURL == "" {
		natsURL = nats.DefaultURL
	}

	nc, err := nats.Connect(natsURL,
		nats.MaxReconnects(-1),
		nats.ReconnectWait(time.Second*5),
		nats.DisconnectErrHandler(func(nc *nats.Conn, err error) {
			log.Printf("NATS disconnected: %v. Reconnecting...", err)
		}),
		nats.ReconnectHandler(func(nc *nats.Conn) {
			log.Println("NATS reconnected!")
		}),
		nats.ClosedHandler(func(nc *nats.Conn) {
			if nc.LastError() != nil {
				log.Fatalf("NATS connection closed: %v", nc.LastError())
			}
			log.Println("NATS connection closed gracefully.")
		}),
	)
	if err != nil {
		return nil, fmt.Errorf("–æ—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ NATS: %w", err)
	}

	return &EnhancedNATSPublisher{
		nc:           nc,
		messagesSent: make(map[string]int64),
	}, nil
}

// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è EnhancedMarketDataHandler
func (enp *EnhancedNATSPublisher) Start() {
	enp.mu.Lock()
	defer enp.mu.Unlock()
	enp.isRunning = true
	log.Println("üöÄ Enhanced NATS Publisher –∑–∞–ø—É—â–µ–Ω")
}

func (enp *EnhancedNATSPublisher) Stop() {
	enp.mu.Lock()
	defer enp.mu.Unlock()
	enp.isRunning = false
	if enp.nc != nil {
		enp.nc.Close()
	}
	log.Println("üõë Enhanced NATS Publisher –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
}

func (enp *EnhancedNATSPublisher) OnMarketDataUpdate(symbol string, data *EnhancedMarketData) {
	enp.mu.Lock()
	if !enp.isRunning {
		enp.mu.Unlock()
		return
	}
	enp.mu.Unlock()

	// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ NATS —Ñ–æ—Ä–º–∞—Ç
	quoteData := enp.convertToQuoteData(data)

	// –ü—É–±–ª–∏–∫—É–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –≤ —Ä–∞–∑–Ω—ã–µ —Ç–æ–ø–∏–∫–∏
	enp.publishBasicData(quoteData)
	enp.publishTradeData(quoteData)
	enp.publishOrderbookData(quoteData)
	enp.publishKlineData(quoteData)
	enp.publishAnalyticsData(quoteData)
}

func (enp *EnhancedNATSPublisher) convertToQuoteData(data *EnhancedMarketData) *EnhancedQuoteData {
	quote := &EnhancedQuoteData{
		Symbol:    data.Symbol,
		Price:     data.Price,
		Market:    data.Market,
		Timestamp: data.Timestamp,
		Volume24h: data.Volume24h,
		Change24h: data.Change24h,
		High24h:   data.High24h,
		Low24h:    data.Low24h,
		// Analytics: data.Analytics, // <--- –≠–¢–û –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û. –ù—É–∂–Ω–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ, –∞ –Ω–µ —Å—Å—ã–ª–∫—É
	}

	// –ö–æ–ø–∏—Ä—É–µ–º Analytics, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
	if data.Analytics != nil {
		quote.Analytics = &AnalyticsMetrics{ // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç AnalyticsMetrics
			BuyVolume1m:         data.Analytics.BuyVolume1m,
			SellVolume1m:        data.Analytics.SellVolume1m,
			BuyVolume5m:         data.Analytics.BuyVolume5m,
			SellVolume5m:        data.Analytics.SellVolume5m,
			BuySellRatio:        data.Analytics.BuySellRatio,
			BidPressure:         data.Analytics.BidPressure,
			AskPressure:         data.Analytics.AskPressure,
			SpreadPercent:       data.Analytics.SpreadPercent,
			LongLiquidations1m:  data.Analytics.LongLiquidations1m,
			ShortLiquidations1m: data.Analytics.ShortLiquidations1m,
			LiquidationRatio:    data.Analytics.LiquidationRatio,
			RSI14:               data.Analytics.RSI14,
			EMA12:               data.Analytics.EMA12,
			EMA26:               data.Analytics.EMA26,
			MACD:                data.Analytics.MACD,
			MACDSignal:          data.Analytics.MACDSignal,
			BollingerUpper:      data.Analytics.BollingerUpper,
			BollingerMiddle:     data.Analytics.BollingerMiddle,
			BollingerLower:      data.Analytics.BollingerLower,
			PriceVelocity:       data.Analytics.PriceVelocity,
			VolumeVelocity:      data.Analytics.VolumeVelocity,
			Momentum5m:          data.Analytics.Momentum5m,
			MarketSentiment:     data.Analytics.MarketSentiment,
			SentimentScore:      data.Analytics.SentimentScore,
			Signals:             data.Analytics.Signals, // –°–ª–∞–π—Å—ã –∫–æ–ø–∏—Ä—É—é—Ç—Å—è –ø–æ —Å—Å—ã–ª–∫–µ, –Ω–æ –¥–ª—è —Å–∏–≥–Ω–∞–ª–æ–≤ —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ
		}
	}

	// Trade –¥–∞–Ω–Ω—ã–µ
	if data.LastTrade != nil {
		quote.LastTradePrice = data.LastTrade.Price
		quote.LastTradeSize = data.LastTrade.Size
		quote.LastTradeSide = data.LastTrade.Side
	}
	quote.TradeCount = data.TradeCount

	// Orderbook –¥–∞–Ω–Ω—ã–µ
	if data.Orderbook != nil {
		if len(data.Orderbook.Bids) > 0 {
			quote.BestBid = data.Orderbook.Bids[0].Price
		}
		if len(data.Orderbook.Asks) > 0 {
			quote.BestAsk = data.Orderbook.Asks[0].Price
		}
		quote.Spread = data.Spread
		// –î–∞–≤–ª–µ–Ω–∏–µ –≤ —Å—Ç–∞–∫–∞–Ω–µ —É–∂–µ –µ—Å—Ç—å –≤ Analytics, –ø–æ—ç—Ç–æ–º—É –∑–¥–µ—Å—å –Ω–µ –Ω—É–∂–Ω–æ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å
		// quote.BidPressure = data.Analytics.BidPressure (–µ—Å–ª–∏ data.Analytics == nil –±—É–¥–µ—Ç –ø–∞–Ω–∏–∫–∞)
		// quote.AskPressure = data.Analytics.AskPressure
		// quote.SpreadPercent = data.Analytics.SpreadPercent
	}

	// Kline –¥–∞–Ω–Ω—ã–µ
	if data.Kline != nil {
		quote.KlineOpen = data.Kline.Open
		quote.KlineHigh = data.Kline.High
		quote.KlineLow = data.Kline.Low
		quote.KlineClose = data.Kline.Close
		quote.KlineVolume = data.Kline.Volume
	}

	return quote
}

func (enp *EnhancedNATSPublisher) publishBasicData(quote *EnhancedQuoteData) {
	// –ë–∞–∑–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –æ —Ü–µ–Ω–µ - –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–µ–π
	basicData := map[string]interface{}{
		"symbol":     quote.Symbol,
		"price":      quote.Price,
		"market":     quote.Market,
		"timestamp":  quote.Timestamp,
		"volume_24h": quote.Volume24h,
		"change_24h": quote.Change24h,
		"high_24h":   quote.High24h,
		"low_24h":    quote.Low24h,
	}

	subject := fmt.Sprintf("quotes.%s.%s",
		strings.ToLower(quote.Market),
		strings.ToLower(quote.Symbol))

	enp.publishToNATS(subject, basicData)
}

func (enp *EnhancedNATSPublisher) publishTradeData(quote *EnhancedQuoteData) {
	if quote.LastTradePrice == 0 {
		return
	}

	tradeData := map[string]interface{}{
		"symbol":           quote.Symbol,
		"market":           quote.Market,
		"timestamp":        quote.Timestamp,
		"last_trade_price": quote.LastTradePrice,
		"last_trade_size":  quote.LastTradeSize,
		"last_trade_side":  quote.LastTradeSide,
		"trade_count":      quote.TradeCount,
	}

	subject := fmt.Sprintf("trades.%s.%s",
		strings.ToLower(quote.Market),
		strings.ToLower(quote.Symbol))

	enp.publishToNATS(subject, tradeData)
}

func (enp *EnhancedNATSPublisher) publishOrderbookData(quote *EnhancedQuoteData) {
	if quote.BestBid == 0 || quote.BestAsk == 0 {
		return
	}

	orderbookData := map[string]interface{}{
		"symbol":         quote.Symbol,
		"market":         quote.Market,
		"timestamp":      quote.Timestamp,
		"best_bid":       quote.BestBid,
		"best_ask":       quote.BestAsk,
		"spread":         quote.Spread,
		"spread_percent": quote.SpreadPercent,
		"bid_pressure":   quote.BidPressure,
		"ask_pressure":   quote.AskPressure,
	}

	subject := fmt.Sprintf("orderbook.%s.%s",
		strings.ToLower(quote.Market),
		strings.ToLower(quote.Symbol))

	enp.publishToNATS(subject, orderbookData)
}

func (enp *EnhancedNATSPublisher) publishKlineData(quote *EnhancedQuoteData) {
	if quote.KlineOpen == 0 {
		return
	}

	klineData := map[string]interface{}{
		"symbol":    quote.Symbol,
		"market":    quote.Market,
		"timestamp": quote.Timestamp,
		"open":      quote.KlineOpen,
		"high":      quote.KlineHigh,
		"low":       quote.KlineLow,
		"close":     quote.KlineClose,
		"volume":    quote.KlineVolume,
	}

	subject := fmt.Sprintf("klines.1m.%s.%s",
		strings.ToLower(quote.Market),
		strings.ToLower(quote.Symbol))

	enp.publishToNATS(subject, klineData)
}

func (enp *EnhancedNATSPublisher) publishAnalyticsData(quote *EnhancedQuoteData) {
	if quote.Analytics == nil {
		return // –ù–µ—á–µ–≥–æ –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å, –µ—Å–ª–∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø—É—Å—Ç–∞
	}

	analyticsData := map[string]interface{}{
		"symbol":                quote.Symbol,
		"market":                quote.Market,
		"timestamp":             quote.Timestamp,
		"buy_volume_1m":         quote.Analytics.BuyVolume1m,
		"sell_volume_1m":        quote.Analytics.SellVolume1m,
		"buy_volume_5m":         quote.Analytics.BuyVolume5m,  // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"sell_volume_5m":        quote.Analytics.SellVolume5m, // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"buy_sell_ratio":        quote.Analytics.BuySellRatio,
		"rsi_14":                quote.Analytics.RSI14,
		"ema_12":                quote.Analytics.EMA12,
		"ema_26":                quote.Analytics.EMA26,
		"macd":                  quote.Analytics.MACD,
		"macd_signal":           quote.Analytics.MACDSignal,
		"bollinger_upper":       quote.Analytics.BollingerUpper,
		"bollinger_middle":      quote.Analytics.BollingerMiddle,
		"bollinger_lower":       quote.Analytics.BollingerLower,
		"market_sentiment":      quote.Analytics.MarketSentiment,
		"sentiment_score":       quote.Analytics.SentimentScore,
		"signals":               quote.Analytics.Signals,
		"bid_pressure":          quote.Analytics.BidPressure,         // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"ask_pressure":          quote.Analytics.AskPressure,         // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"spread_percent":        quote.Analytics.SpreadPercent,       // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"long_liquidations_1m":  quote.Analytics.LongLiquidations1m,  // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"short_liquidations_1m": quote.Analytics.ShortLiquidations1m, // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"liquidation_ratio":     quote.Analytics.LiquidationRatio,    // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"price_velocity":        quote.Analytics.PriceVelocity,       // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"volume_velocity":       quote.Analytics.VolumeVelocity,      // <--- –î–û–ë–ê–í–õ–ï–ù–û
		"momentum_5m":           quote.Analytics.Momentum5m,          // <--- –î–û–ë–ê–í–õ–ï–ù–û
	}

	subject := fmt.Sprintf("analytics.%s.%s",
		strings.ToLower(quote.Market),
		strings.ToLower(quote.Symbol))

	enp.publishToNATS(subject, analyticsData)
}

func (enp *EnhancedNATSPublisher) publishToNATS(subject string, data interface{}) {
	jsonData, err := json.Marshal(data)
	if err != nil {
		log.Printf("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è %s: %v", subject, err)
		return
	}

	err = enp.nc.Publish(subject, jsonData)
	if err != nil {
		log.Printf("‚ùå –û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤ %s: %v", subject, err)
		return
	}

	// –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
	enp.statsMux.Lock()
	enp.messagesSent[subject]++
	enp.statsMux.Unlock()
}

func (enp *EnhancedNATSPublisher) GetStats() map[string]int64 {
	enp.statsMux.RLock()
	defer enp.statsMux.RUnlock()

	stats := make(map[string]int64)
	for subject, count := range enp.messagesSent {
		stats[subject] = count
	}
	return stats
}
